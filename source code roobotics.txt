*Write Python code to test motors 
import RPi.GPIO as GPIO
import time
GPIO.setmode(GPIO.BOARD)
GPIO.setwarnings(False)
button=12
DC_motor_a=7
DC_motor_b=11

GPIO.setup(DC_motor_a,GPIO.OUT)
GPIO.setup(DC_motor_B,GPIO.OUT)
GPIO.setup(button ,GPIO.IN,pull_up_down=GPIO.PUD_UP)

while(1):
	if GPIO.input(button)==GPIO.LOW:
		GPIO.output(DC_MOTOR_a, GPIO.HIGH)
		GPIO.output(DC_MOTOR_b, GPIO.LOW)
		time.sleep(0.1)
	else:
		GPIO.output(DC_MOTOR_a, GPIO.LOW)
		GPIO.output(DC_MOTOR_b, GPIO.HIGH)		
		time.sleep(0.1)

*Write a script to follow a predetermined path 
const int pingPin = 7;
const int red=11;
const int blue=10;
int green=9;
void setup() {
  // initialize serial communication:
  Serial.begin(9600);
  pinMode(red,OUTPUT);
  pinMode(blue,OUTPUT);
  pinMode(green,OUTPUT);
}

void loop() {
  // establish variables for duration of the ping, and the distance result
  // in inches and centimeters:
  long duration, inches, cm;

  // The PING))) is triggered by a HIGH pulse of 2 or more microseconds.
  // Give a short LOW pulse beforehand to ensure a clean HIGH pulse:
  pinMode(pingPin, OUTPUT);
  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(5);
  digitalWrite(pingPin, LOW);

  // The same pin is used to read the signal from the PING))): a HIGH pulse
  // whose duration is the time (in microseconds) from the sending of the ping
  // to the reception of its echo off of an object.
  pinMode(pingPin, INPUT);
  duration = pulseIn(pingPin, HIGH);

  // convert the time into a distance
  inches = microsecondsToInches(duration);
  cm = microsecondsToCentimeters(duration);

  Serial.print(inches);
  Serial.print("in, ");
  Serial.print(cm);
  Serial.print("cm");
  Serial.println();
  
  if(inches<10){
    digitalWrite(red,HIGH);
    digitalWrite(green,LOW);
    digitalWrite(blue,LOW);
  }
  else if (inches>10 && inches<50){
    digitalWrite(red,LOW);
    digitalWrite(green,LOW);
    digitalWrite(blue,HIGH); 
  }
  
  else{ 
    digitalWrite(red,LOW);
    digitalWrite(green,HIGH);
    digitalWrite(blue,LOW); 
  }
}
long microsecondsToInches(long microseconds) {
  // According to Parallax's datasheet for the PING))), there are 73.746
  // microseconds per inch (i.e. sound travels at 1130 feet per second).
  // This gives the distance travelled by the ping, outbound and return,
  // so we divide by 2 to get the distance of the obstacle.
  // See: http://www.parallax.com/dl/docs/prod/acc/28015-PING-v1.3.pdf
  return microseconds / 74 / 2;
}

long microsecondsToCentimeters(long microseconds) {
  // The speed of sound is 340 m/s or 29 microseconds per centimeter.
  // The ping travels out and back, so to find the distance of the object we
  // take half of the distance travelled.
  return microseconds / 29 / 2;
}

*Develop Python code for testing the sensors
int pirsensor = 0;

void setup()
{
  pinMode(A0, INPUT);
  Serial.begin(9600);
  pinMode(7, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(10, OUTPUT);
  pinMode(10, OUTPUT);
}

void loop()
{
  pirsensor = analogRead(A0);
  Serial.println(pirsensor);
  if (pirsensor >= 100) {
    digitalWrite(7, LOW);
    digitalWrite(6, HIGH);
    tone(10, 92, 100); // play tone 30 (F#2 = 92 Hz)
  } else {
    digitalWrite(7, HIGH);
    digitalWrite(6, LOW);
    digitalWrite(10, LOW);
  }
  delay(10); // Delay a little bit to improve simulation performance
}

*Add pan and tilt service to the robot object and test it
#include <Servo.h>
int sensorValue = 0;
int outputValue = 0;
int sensorValue1 = 0;
int outputValue1 = 0;
Servo servo_9;
Servo servo_10;
void setup()
{
  pinMode(A0, INPUT);
  servo_9.attach(9, 500, 2500);
  pinMode(A1, INPUT);
  servo_10.attach(10, 500, 2500);
}
void loop()
{
  sensorValue = analogRead(A0);
  outputValue = map(sensorValue, 0, 1023, 0, 180);
  servo_9.write(outputValue);
  delay(10); // Delay a little bit to improve simulation performance
  sensorValue1 = analogRead(A1);
  outputValue1 = map(sensorValue1, 0, 1023, 0, 180);
  servo_10.write(outputValue1);
  delay(10); // Delay a little bit to improve simulation performance
}

*Create an obstacle avoidance behaviour for robot and test it.
//code for obstacle avoiding robot
#include <LiquidCrystal.h>
LiquidCrystal lcd(8,9,10,11,12,13);
long cm, duration;
const int echoPin = 7;
const int trigPin = 6;
const int lm1 = 2;
const int lm2 = 3;
const int rm1 = 4;
const int rm2 = 5;
void setup()
{
  pinMode(lm1, OUTPUT);
  pinMode(lm2, OUTPUT);
  pinMode(rm1, OUTPUT);
  pinMode(rm2, OUTPUT);
  
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT); 
  Serial.begin(9600);
  lcd.begin(16,2);
}
void loop()
{
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(5);
  digitalWrite(trigPin, LOW);
  duration = pulseIn(echoPin,HIGH);
  //converting time into distance in centimetre  
  cm = duration*0.034/2;  
  if(cm < 20)
  {
    stop_bot();
    delay(2000);  
    go_back();
    delay(2000);  
    stop_again();
    delay(1000);    
    go_left();
    delay(1000);  
  }
  else
  {
    go_straight();
    delay(1000); 
  }
Serial.print("Distance:CM");
Serial.println(cm);
}
void go_straight()
{
lcd.setCursor(0,0);
lcd.print("NOTHING AHEAD");
lcd.setCursor(0,1);
lcd.print("MOVING FORWARD");
  digitalWrite(lm1,HIGH);
  digitalWrite(lm2,LOW);
  digitalWrite(rm1,HIGH);
  digitalWrite(rm2,LOW);
}
void go_back()
{
lcd.clear();
lcd.setCursor(0,0);
lcd.print("TAKING REVERSE");
lcd.setCursor(0,1);
lcd.print(cm);
  digitalWrite(lm2,HIGH);
  digitalWrite(lm1,LOW);
  digitalWrite(rm2,HIGH);
  digitalWrite(rm1,LOW);
  
}

void stop_bot()
{
lcd.clear();
lcd.setCursor(0,0);
lcd.print("SOMETHING AHEAD");
lcd.setCursor(0,1);
lcd.print("STOP!");
  digitalWrite(lm1,LOW);
  digitalWrite(lm2,LOW);
  digitalWrite(rm1,LOW);
  digitalWrite(rm2,LOW);
}
void stop_again()
{
lcd.clear();
lcd.setCursor(0,0);
lcd.print("BREAK FOR TURN");
  digitalWrite(lm1,LOW);
  digitalWrite(lm2,LOW);
  digitalWrite(rm1,LOW);
  digitalWrite(rm2,LOW);
}
void go_left()
{
lcd.clear();
lcd.setCursor(0,0);
lcd.print("TURNING LEFT");
lcd.setCursor(0,1);
  lcd.print(cm);  
  digitalWrite(lm1,LOW);
  digitalWrite(lm2,LOW);
  digitalWrite(rm1,HIGH);
  digitalWrite(rm2,LOW);
}
void go_right()
{
lcd.clear();
lcd.setCursor(0,0);
lcd.print("TURNING RIGHT");
lcd.setCursor(0,1);
  lcd.print(cm);  
  digitalWrite(lm1,HIGH);
  digitalWrite(lm2,LOW);
  digitalWrite(rm1,LOW);
  digitalWrite(rm2,LOW);
}

*Detect faces with Haar cascades
import cv2
from google.colab.patches import cv2_imshow
img = cv2.imread('test.jpg')
gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
haar_cascade = cv2.CascadeClassifier(cv2.data.haarcascades +"haarcascade_frontalface_default.xml")
eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_eye.xml")
faces_rect = haar_cascade.detectMultiScale(gray_img, 1.3, 5)
eyes = eye_cascade.detectMultiScale(gray_img)
for (x, y, w, h) in faces_rect:
    cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)
for (ex, ey, ew, eh) in eyes:
    cv2.rectangle(img, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2)
cv2_imshow(img)

